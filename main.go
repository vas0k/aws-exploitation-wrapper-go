package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"

	expect "github.com/google/goexpect"
)

// Set the timeout
const (
	timeout = 600 * time.Second
)

// Set the values, to wait for during pacu's run
var (
	// input data variables
	keyMap     map[string]interface{}
	keyFile    string
	resultFile string

	// Variables used for concurrent execution
	wg       sync.WaitGroup
	parallel int

	// command variables
	commands = []string{
		"enum__secrets",
		"lambda__enum",
		"ec2__enum",
	}

	// Regular expressions for the expect framework to use.
	chooseOptionRE    = regexp.MustCompile("option:")
	pacuRE            = regexp.MustCompile(">")
	keyInputRE        = regexp.MustCompile("]:")
	regionSelectionRE = regexp.MustCompile("(y/n)")
)

func main() {
	flag.StringVar(&keyFile, "secrets", "", "Path to AWS secrets file. eg: aws.json")
	flag.StringVar(&resultFile, "resultFile", "", "Path to store the results file (csv format)")
	flag.IntVar(&parallel, "parallel", 10, "Number of parallel threads to execute")

	flag.Parse()

	if resultFile == "" || keyFile == "" {
		flag.Usage()
		os.Exit(1)
	}

	fmt.Printf("Using file %v, with parallel threads set as %v\n", keyFile, parallel)

	data, err := os.ReadFile(keyFile)
	if err != nil {
		panic(err)
	}

	err = json.Unmarshal(data, &keyMap)

	if err != nil {
		panic(err)
	}

	// Parse the retrieved Json
	AWSKeys := keyMap["AWS_keys"].(map[string]interface{})
	keyValueArray := AWSKeys["key_value"].([]interface{})

	//Create a channel which would contain the secrets
	var keys = make(chan map[string]string)

	// Start a thread which will feed each AWS key into the channel
	go func(keyValueArray []interface{}) {
		for i := 0; i < len(keyValueArray); i++ {
			clientId := keyValueArray[i].(map[string]interface{})["client_id"].(string)
			clientSecret := keyValueArray[i].(map[string]interface{})["client_secret"].(string)

			keys <- map[string]string{"clientId": clientId, "clientSecret": clientSecret}
		}

		// Close the channel, so that workers can stop looking for info inside it.
		close(keys)
	}(keyValueArray)

	startTime := time.Now()

	// Create a file to store the result
	file, _ := os.Create(resultFile)
	w := bufio.NewWriter(file)

	// Loop over the json array
	for worker := 0; worker < parallel; worker++ {
		// Add the counter to the WaitGroup
		wg.Add(1)

		// Start a thread for a worker
		go func(workerId int) {
			defer wg.Done()

			// Spawn Pacu
			process, _, err := expect.Spawn("pacu", -1)
			if err != nil {
				panic(err)
			}

			_, _, err = process.Expect(chooseOptionRE, timeout)
			checkError(err)
			process.Send("1\n")

			_, _, err = process.Expect(pacuRE, timeout)
			checkError(err)
			fmt.Println("Worker:[" + strconv.Itoa(workerId) + "] Spawned a Pacu shell")

			defer process.Close()

			// Receive map from channel
			for keyMap := range keys {
				clientId := keyMap["clientId"]
				clientSecret := keyMap["clientSecret"]

				// Set of steps to wait for a prompt within the Pacu session and send specific commands. Here we are setting the AWS keys,
				// and providing the name of the module for Pacu to execute.
				process.Send("set_keys\n")
				fmt.Println("Worker:[" + strconv.Itoa(workerId) + "] Setting the keys")

				_, _, err = process.Expect(keyInputRE, timeout)
				checkError(err)
				process.Send(fmt.Sprintf("test_AWS_Key_%v\n", workerId))
				fmt.Println("Worker:[" + strconv.Itoa(workerId) + "] Done setting the key alias")

				_, _, err = process.Expect(keyInputRE, timeout)
				checkError(err)
				process.Send(fmt.Sprintf("%v\n", clientId))
				fmt.Println("Worker:[" + strconv.Itoa(workerId) + "] Done setting the Access key")

				_, _, err = process.Expect(keyInputRE, timeout)
				checkError(err)
				process.Send(fmt.Sprintf("%v\n", clientSecret))
				fmt.Println("Worker:[" + strconv.Itoa(workerId) + "] Done setting the Secret Access key")

				_, _, err = process.Expect(keyInputRE, timeout)
				checkError(err)
				process.Send("\n")

				_, _, err = process.Expect(pacuRE, timeout)
				checkError(err)

				// Execute list of commands
				for _, command := range commands {
					process.Send(fmt.Sprintf("exec %v\n", command))
					fmt.Printf("Worker:["+strconv.Itoa(workerId)+"] Running command %v\n", command)

					_, _, err = process.Expect(regionSelectionRE, timeout)
					checkError(err)
					fmt.Println("Worker:[" + strconv.Itoa(workerId) + "] Selected the region. The module has started execution")
					process.Send("y\n")

					// Retrieve the final output from the last command.
					outputString, _, err := process.Expect(pacuRE, timeout)
					checkError(err)
					fmt.Println(outputString)

					// Filter the output to retrieve only useful stuff.
					outputString = outputString[strings.LastIndex(outputString, "]"):]
					outputString = strings.ReplaceAll(outputString, "\n", "")

					csvString := fmt.Sprintf("%v,%v,%v\n", clientId, command, outputString)

					fmt.Println(csvString)

					w.Write([]byte(csvString))
					w.Flush()
				}
			}
		}(worker)
	}

	// Wait for all threads to complete.
	wg.Wait()

	endTime := time.Now()

	fmt.Printf("Program took %v to complete.\n", (endTime.Sub(startTime)))
}

// Helper function to check for errors. Stop the program, if there are any
func checkError(err error) {
	if err != nil {
		panic(err.Error())
	}
}
